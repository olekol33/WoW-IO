import gzip
import os
import pickle
from typing import Iterator, Tuple, List, MutableMapping, Set

from tqdm import tqdm


from Modules import World, ContinentName


def print_a(a, b):
    assert a == b, f'{a} is not equal {b}'
    print(a)

# debugging function for asserting World works as it should.
def test_world():
    w = World()

    print('Hello World')

    # WORLD TESTS
    # for n, z in w.get_zones().items():
    #     print_a(n, z.get_name())
    # for c in w.get_cities():
    #     print(c.get_name())
    # for n, c in w.get_named_cities().items():
    #     print_a(n, c.get_name())
    print_a(len(w.get_zones()), 52)
    print_a(len(w.get_cities()), 281)
    print_a(len(w.get_named_cities()), 62)
    print_a(w.is_zone('Hyjal'), False)
    print_a(w.is_city('Hyjal'), True)
    print_a(w.is_zone('Azshara'), True)
    print_a(w.is_city('Azshara'), False)
    print_a(w.get_zone('Azshara').get_name(), 'Azshara')
    print_a(w.get_city('Hyjal').get_name(), 'Hyjal')
    print_a(w.get_location(w.get_continent(ContinentName.Kalimdor), 1, 2).get_zone().get_name(), 'Teldrassil')
    # TOTO uncomment after filling neighbors graph
    # print_a(w.are_neighbors('Azshara', 'Ashenvale'), True)
    # print_a(w.are_neighbors(w.get_zone('Azshara'), 'Ashenvale'), True)
    # print_a(w.are_neighbors('Azshara', 'Tanaris'), False)

    # CONTINENT TESTS
    k = w.get_continent(ContinentName.Kalimdor)
    # for n, z in k.get_zones().items():
    #     print_a(n, z.get_name())
    # for c in k.get_cities():
    #     print(c.get_name())
    # for n, c in k.get_named_cities().items():
    #     print_a(n, c.get_name())
    print_a(len(k.get_zones()), 21)
    print_a(k.get_location(1, 2).get_zone().get_name(), 'Teldrassil')
    print_a(k.get_name().value, 'kalimdor')
    print_a(k.get_bounds(), ((0, 0), (187, 421)))
    print_a(k.is_zone('Hyjal'), False)
    print_a(k.is_zone('Azshara'), True)
    print_a(k.is_zone('Badlands'), False)
    print_a(k.get_zone('Azshara').get_name(), 'Azshara')

    # ZONE TESTS
    a = k.get_zone('Azshara')
    print_a(a.get_name(), 'Azshara')

    # for loc in a.get_locations():
    #     print(loc.get_coords())

    locs = list(a.get_locations())
    print_a(len(locs), 3404)

    print_a(a.get_bounds(), ((113, 94), (187, 140)))
    print_a(a.get_continent().get_name().value, 'kalimdor')
    print_a(a.get_random_location(locs[0]) in locs, True)
    print_a(a.get_random_location(locs[0]) in locs, True)
    print_a(a.get_random_location(locs[0]) in locs, True)
    print_a(a.get_random_location(locs[0]) in locs, True)
    print_a(a.get_random_location(locs[0]) in locs, True)

    # CITY TESTS
    h = w.get_city('Hyjal')
    print_a(h.get_name(), 'Hyjal')
    print_a(h.get_city_type().value, (2, 2))
    print_a(h.get_zone().get_name(), 'Felwood')
    print_a(h.get_zone().get_continent().get_name().value, 'kalimdor')
    print_a(h.get_bounds(), ((99, 74), (101, 76)))

    # for loc in h.get_locations():
    #     print(loc.get_coords())
    locs = list(h.get_locations())
    print_a(len(locs), 4)
    print_a(h.get_random_location() in locs, True)
    print_a(h.get_random_location() in locs, True)
    print_a(h.get_random_location() in locs, True)
    print_a(h.get_random_location() in locs, True)
    print_a(h.get_random_location() in locs, True)


# iterator of all ios (aid, (int)time, obj_id, type) in scene "scene_num".
def ios(scene_num: int, input_folder: str, pbar: tqdm) -> Iterator[Tuple[str, int, str, str]]:
    folder: str = os.path.join(input_folder, f'Scene{scene_num}')
    scene_files: Iterator[str] = (file for file in os.listdir(folder) if file.startswith(f'scene{scene_num}_'))
    for file in sorted(scene_files, key=lambda x: int(x.split('_')[1].split('-')[0])):
        is_compressed = file.split('.')[-1] == 'gz'
        with gzip.open(os.path.join(folder, file), 'rt') if is_compressed else open(os.path.join(folder, file)) as f:
            for l in f:
                if l:
                    # example line: A_0, 0.0, AO_226, 0
                    line: List[str] = l.split(', ')  # the last element ends with newline
                    yield line[0], int(line[1].split('.')[0]), line[2], line[3]
        pbar.update(10)


# get number of minutes in the scene.
def get_scene_length(scene_num: int, input_folder: str) -> int:
    folder: str = os.path.join(input_folder, f'Scene{scene_num}')
    scene_files: Iterator[str] = (file for file in os.listdir(folder) if file.startswith(f'scene{scene_num}_'))
    return max((int(x.split('_')[1].split('-')[1].split('.')[0]) for x in scene_files), default=-1) + 1


def test_scene(scene_num: int, input_folder: str) -> None:
    """
    test that every io generated by the input scene should have been generated.
    requires a test_data_scene{scene_num}.pickle file in the same folder, generated by run -t.
    :param scene_num: scene number
    :param input_folder: the scenes folder
    """
    print('Reading debug test data...', end='')
    with open(os.path.join(input_folder, f'Scene{scene_num}', f"test_data_scene{scene_num}.pickle"), 'rb') as pickle_f:
        dicts: Tuple[
            MutableMapping[Tuple[int, str], Tuple[str, str]],
            MutableMapping[Tuple[int, str], Set[str]],
            MutableMapping[Tuple[int, str], Set[str]]
        ] = pickle.load(pickle_f)
        avatars, locs, guilds = dicts
    print(' - DONE!')
    # avatar_dict: (time, avatar) -> (loc, guild)
    # loc_dict: (time, loc) -> {ao1, ao2, ao3}
    # guild_dict: (time, guild) -> {ao1, ao2, ao3}

    with tqdm(total=get_scene_length(scene_num, input_folder)) as pbar:
        for aid, time, obj, io_tid in ios(scene_num, input_folder, pbar):
            loc, guild = avatars[(time, aid)]
            assert loc
            if obj[0] == 'L':
                assert loc == obj
            elif obj[0] == 'G':
                assert guild == obj
            elif obj[0] == 'A':
                same_loc = obj in locs[(time, loc)]
                same_guild = guild is not None and obj in guilds[(time, guild)]
                assert same_loc or same_guild
            else:
                assert False
    print(f'Test for scene {scene_num} - PASSED')
